# Icu4Scala

[![License](http://img.shields.io/:license-apache-blue.svg)](http://www.apache.org/licenses/LICENSE-2.0.html)
![example branch parameter](https://github.com/marmeblade/icu4scala/workflows/CI/badge.svg?branch=main)
[![Maven Central](https://maven-badges.herokuapp.com/maven-central/works.perpetuum/sbt-icu4scala/badge.svg)](https://maven-badges.herokuapp.com/maven-central/works.perpetuum/sbt-icu4scala)

Type-safe, high-performance internationalization (i18n) for Scala projects,
generated at compile-time. Icu4Scala uses a custom 
[ICU MessageFormat](https://unicode-org.github.io/icu/userguide/format_parse/messages/) parser to use these in 
complex translation schemes. 

This library is highly inspired by [sbt-i18n](https://github.com/ant8e/sbt-i18n), however
it does not rely on Java MessageFormat API, 
so is available in Scala JVM, Scala JS and 
Scala Native for Scala Version 2.12, 2.13 and 3.3.
The library consists of a core part that parses the ICU expressions and defines the AST,
as well as the Bundle Format and their Translator instance. 
That way we can translate entities using the common string keys (e.g. "x.y.z").

## Motivation

The main selling point is the compile-time generation of Bundle classes.
These are generated by importing [HOCON](https://github.com/lightbend/config) (.conf) 
files from a configured source folder. On every change a recompile is triggered so the changes
in the translation files are immediately available. The generated Bundle classes use "val" 
for static translations and "def" for parameterized translations.
Strings are build using the highest performance mechanism: StringBuilder.
So in the end the library is very efficient in the runtime and also quite fast at compile time.
Other libraries rely on complex MessageFormat parsing and need to read from files on runtime.
Here everything is directly available in code, which is especially useful for Scala JS projects.
The benefits are even bigger when using client-server projects with Scala JVM and Scala JS, 
where translations might be needed on client AND server. In that case put the translations 
in the shared project and have it in both backend and frontend.

## Installation

To use the code-generator library declare the sbt plugin in your plugins.sbt

```scala
addSbtPlugin("works.perpetuum" % "sbt-icu4scala" % "<VERSION>")
```

For every project in your build use the Auto-Plugin and configure it

```scala
lazy val root = (project in file("."))
  .enablePlugins(Icu4ScalaPlugin)
  .settings(
    icuBundlePackageName := "com.example" // The setting to change the package in the Bundle.scala output
  )
```

Then create a folder under src/main besides your scala source folder and call it "icu".
Here you place all the *.conf files with your translations. The first key of the hocon file is always the language.
Then you declare your actual key structure underneath

```hocon
de {
  firstKey {
    static = "i18n macht Spaß! (1)"
    simple = "Hallo, {name}! (1)"
    complex = """{gender_of_host, select,
  female {
    {num_guests, plural,
      =0 {{host} lädt nicht zu einer Party ein. (1)}
      =1 {{host} lädt {guest} zu ihrer Party ein. (1)}
      =2 {{host} lädt {guest} und eine andere Person zu ihrer Party ein. (1)}
      other {{host} lädt {guest} und # andere Personen zu ihrer Party ein.}}}
  male {
    {num_guests, plural,
      =0 {{host} lädt nicht zu einer Party ein. (1)}
      =1 {{host} lädt {guest} zu seiner Party ein. (1)}
      =2 {{host} lädt {guest} und eine andere Person zu seiner Party ein. (1)}
      other {{host} lädt {guest} und # andere Personen zu seiner Party ein!}}}
  other {
    {num_guests, plural,
      =0 {{host} lädt nicht zu einer Party ein. (1)}
      =1 {{host} lädt {guest} zu ihrer Party ein. (1)}
      =2 {{host} lädt {guest} und eine andere Person zu ihrer Party ein. (1)}
      other {{host} lädt {guest} und # andere Personen zu ihrer Party ein. (1)}}}}
"""
  }
}
```

It is advised to create a file for every language, the filename doesn't matter though. 
The HOCON files are all combined into one and will generate a single Bundle.scala per project.
So you can use as many files as you want, but be aware that a single change will regenerate the 
entire Bundle.scala. 
Missing keys for one language will be constructed with unknown translation strings in the form
of '??missing.translation.key??', where the key is the actual path that is missing a translation.

The Bundle object is available under "target/scala-<version>/src_managed/main/sbt-icu4scala/Bundle.scala".

```scala
package com.example

object Bundle {
  abstract class I18N {

    abstract class Key1 {
      def simple(name: String): String
      def complex(host: String, guest: String, num_guests: Long, gender_of_host: String): String
      def static: String
    }
    def key1: Key1
  }

  object en extends I18N {
    object key1 extends Key1 {
      def simple(name: String): String = {
        val sb = new StringBuilder()
        sb.append("""Hello, """)
        sb.append(name)
        sb.append("""! (1)""")
        sb.toString()
      }
      def complex(host: String, guest: String, num_guests: Long, gender_of_host: String): String = {
        val sb = new StringBuilder()
        gender_of_host match {
          case """female""" =>
            num_guests match {
              case 0 =>
                sb.append(host)
                sb.append(""" does not give a party. (1)""")
              case 1 =>
                sb.append(host)
                sb.append(""" invites """)
                sb.append(guest)
                sb.append(""" to her party. (1)""")
              case 2 =>
                sb.append(host)
                sb.append(""" invites """)
                sb.append(guest)
                sb.append(""" and one other person to her party. (1)""")
              case _ =>
                sb.append(host)
                sb.append(""" invites """)
                sb.append(guest)
                sb.append(""" and """)
                sb.append(num_guests)
                sb.append(""" other people to her party. (1)""")
            }
          case """male""" =>
            num_guests match {
              case 0 =>
                sb.append(host)
                sb.append(""" does not give a party. (1)""")
              case 1 =>
                sb.append(host)
                sb.append(""" invites """)
                sb.append(guest)
                sb.append(""" to his party. (1)""")
              case 2 =>
                sb.append(host)
                sb.append(""" invites """)
                sb.append(guest)
                sb.append(""" and one other person to his party. (1)""")
              case _ =>
                sb.append(host)
                sb.append(""" invites """)
                sb.append(guest)
                sb.append(""" and """)
                sb.append(num_guests)
                sb.append(""" other people to his party. (1)""")
            }
          case _ =>
            num_guests match {
              case 0 =>
                sb.append(host)
                sb.append(""" does not give a party. (1)""")
              case 1 =>
                sb.append(host)
                sb.append(""" invites """)
                sb.append(guest)
                sb.append(""" to their party. (1)""")
              case 2 =>
                sb.append(host)
                sb.append(""" invites """)
                sb.append(guest)
                sb.append(""" and one other person to their party. (1)""")
              case _ =>
                sb.append(host)
                sb.append(""" invites """)
                sb.append(guest)
                sb.append(""" and """)
                sb.append(num_guests)
                sb.append(""" other people to their party. (1)""")
            }
        }
        sb.toString()
      }
      val static: String = {
        """i18n is fun! (1)"""
      }
    }
  }

  object de extends I18N {
    object key1 extends Key1 {
      def simple(name: String): String = {
        val sb = new StringBuilder()
        sb.append("""Hallöchen, """)
        sb.append(name)
        sb.append("""! (1)""")
        sb.toString()
      }
      def complex(host: String, guest: String, num_guests: Long, gender_of_host: String): String = {
        val sb = new StringBuilder()
        gender_of_host match {
          case """female""" =>
            num_guests match {
              case 0 =>
                sb.append(host)
                sb.append(""" lädt nicht zu einer Party ein. (1)""")
              case 1 =>
                sb.append(host)
                sb.append(""" lädt """)
                sb.append(guest)
                sb.append(""" zu ihrer Party ein. (1)""")
              case 2 =>
                sb.append(host)
                sb.append(""" lädt """)
                sb.append(guest)
                sb.append(""" und eine andere Person zu ihrer Party ein. (1)""")
              case _ =>
                sb.append(host)
                sb.append(""" lädt """)
                sb.append(guest)
                sb.append(""" und """)
                sb.append(num_guests)
                sb.append(""" andere Personen zu ihrer Party ein.""")
            }
          case """male""" =>
            num_guests match {
              case 0 =>
                sb.append(host)
                sb.append(""" lädt nicht zu einer Party ein. (1)""")
              case 1 =>
                sb.append(host)
                sb.append(""" lädt """)
                sb.append(guest)
                sb.append(""" zu seiner Party ein. (1)""")
              case 2 =>
                sb.append(host)
                sb.append(""" lädt """)
                sb.append(guest)
                sb.append(""" und eine andere Person zu seiner Party ein. (1)""")
              case _ =>
                sb.append(host)
                sb.append(""" lädt """)
                sb.append(guest)
                sb.append(""" und """)
                sb.append(num_guests)
                sb.append(""" andere Personen zu seiner Party ein!""")
            }
          case _ =>
            num_guests match {
              case 0 =>
                sb.append(host)
                sb.append(""" lädt nicht zu einer Party ein. (1)""")
              case 1 =>
                sb.append(host)
                sb.append(""" lädt """)
                sb.append(guest)
                sb.append(""" zu ihrer Party ein. (1)""")
              case 2 =>
                sb.append(host)
                sb.append(""" lädt """)
                sb.append(guest)
                sb.append(""" und eine andere Person zu ihrer Party ein. (1)""")
              case _ =>
                sb.append(host)
                sb.append(""" lädt """)
                sb.append(guest)
                sb.append(""" und """)
                sb.append(num_guests)
                sb.append(""" andere Personen zu ihrer Party ein. (1)""")
            }
        }
        sb.toString()
      }
      val static: String = {
        """i18n macht Spaß! (1)"""
      }
    }
  }

  val languages: Map[String, I18N] = Map(
    "en" -> en,
    "de" -> de
  )
}
```

## Usuage

The Bundle has no dependencies (plain old scala objects) and uses pattern matching and 
StringBuilder to construct complex translation rules. With `Bundle.languages` we get a Map that maps 
from language codes to the concrete language implementations. These are all of super type `I18N` 
so very portable in your application.

To call the translation just use the abstract I18N class in your project and navigate to the right key.

```scala
@main
def main(): Unit = {
  val bundle = com.example.Bundle
  val languageCode = "en"
  
  def myFunction(i18n: com.example.Bundle.I18N): Unit = {
    println(i18n.key1.complex("John", "Mary", 20, "male"))
  }
  
  val i18n = bundle.languages.getOrElse(languageCode, bundle.en)
  
  myFunction(i18n)
}
```

The output will look like this

```
John invites Mary and 20 other people to his party. (1)
```

## Performance

I tested on a i5 laptop and it took around 3 seconds to generate the Bundle for 3000 keys and 4 languages, 
resulting in a 4MB Bundle.scala file. Only on a clean or a change in one of the .conf files the rebuild is
actually triggered. So this library is very incremental compile friendly.

## License

This project is licensed under the Apache 2.0 License. See the LICENSE file for details.